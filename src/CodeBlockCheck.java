/**
 * Created by Juan on 23/05/2016
 */

class CodeBlockCheck {
    private String selectedText;
    private boolean openRegex;

    CodeBlockCheck(String selectedText) {
        this.selectedText = selectedText;
    }

    /**
     * I'm not entirely sure why I am using "invoke", it was auto-generated by intelliJ when I extracted the method
     *
     * @return isCodeBlock? it checks if the selected code is balanced (amount of "{" and "}") and other minor checks.
     */
    boolean invoke() {
        int leftBalance = 1;
        boolean stopCount = false;
        boolean singleStop = false;
        boolean multiLineStop = false;
        boolean doubleStop = false;
        boolean singleLineStop = false;
        boolean regexStop = false;


        char[] chars = selectedText.toCharArray();
        int i;

        /**
         * IMPORTANT! I don't care about <!-- or --> comments on js (yes, they exist).
         * If you happen to use that kind of comment, you deserve no respect nor compatible plugins
         * ...
         * you monster.
         */

        for (i = selectedText.indexOf('{') + 1; i < chars.length && leftBalance > 0; i++) {
            switch (chars[i]) {
                // Stop counting when a string opens
                case '"':
                    if (i > 0 && chars[i - 1] != '\\' && !singleStop && !multiLineStop && !singleLineStop) {
                        stopCount = !stopCount;
                        doubleStop = !doubleStop;
                    }
                    break;
                // Stop counting when a string opens
                case '\'':
                    if (i > 0 && chars[i - 1] != '\\' && !doubleStop && !multiLineStop && !singleLineStop) {
                        stopCount = !stopCount;
                        singleStop = !singleStop;
                    }
                    break;
                // Stop counting when a comment or regex opens
                case '/':
                    if (i + 1 < chars.length) {
                        if (chars[i + 1] == '/' && !singleStop && !doubleStop) {
                            stopCount = true;
                            singleLineStop = true;
                        } else if (chars[i + 1] == '*' && !singleStop && !doubleStop) {
                            stopCount = true;
                            multiLineStop = true;
                            // This is different, because you CAN close a multiline comment between quotes
                        } else if (multiLineStop && chars[i - 1] == '*') {
                            multiLineStop = false;
                            stopCount = false;
                        }
                        else if (!stopCount && i > 0 && isOpenRegex(chars, i)) {
                            stopCount = true;
                            regexStop = true;
                        } else if (regexStop) {
                            if (chars[i - 1] != '\\') {
                                regexStop = false;
                                stopCount = false;
                            }
                        }
                    }
                    break;
                // Continue counting when a line breaks outside a string or comment
                case '\n':
                    if (i > 0)
                        if ((!(singleStop || doubleStop) || (chars[i - 1] != '\\')) && !multiLineStop) {
                            stopCount = false;
                            singleLineStop = false;
                        }
                    break;
                // Check balance
                case '{':
                    if (!stopCount) {
                        ++leftBalance;
                    }
                    break;
                // Check balance
                case '}':
                    if (!stopCount) {
                        --leftBalance;
                    }
                    break;
            }
        }
        return leftBalance == 0 && selectedText.substring(i).matches("(\\s|;)*");
    }

    /**
     * @param chars charArray
     * @param i     current "/" position
     * @return if it is opening a regex
     */
    private boolean isOpenRegex(char[] chars, int i) {
        boolean result = false;

        for (i -= 1; i > 0; i--) {
            if (chars[i] == '\n') {
                result = true;
                break;
            } else {
                if (!Character.isWhitespace(chars[i])) {

                    if (chars[i] == '}' ||
                            chars[i] == '=' ||
                            chars[i] == ';' ||
                            chars[i] == ':' ||
                            chars[i] == ',' ||
                            chars[i] == '+' ||
                            chars[i] == '-' ||
                            chars[i] == '*') {

                        result = true;
                        break;

                    } else {
                        break;
                    }
                }
            }
        }
        return result;

    }
}
